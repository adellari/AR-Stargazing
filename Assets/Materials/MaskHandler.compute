
#pragma kernel JFA_Init
#pragma kernel JFA_Crawl
#pragma kernel JFA_DistanceField

RWTexture2D<float4> Result;
float2 TexSize;
int offset;

[numthreads(8, 8, 1)]
void JFA_Init(uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(id.xy / TexSize);
    Result[id.xy] = float4(uv, 0, 1) * step(0.1, Result[id.xy].r);
    
}


[numthreads(8, 8, 1)]
void JFA_Crawl(uint3 id : SV_DispatchThreadID)
{
    const float2 uv = float2(id.xy / TexSize);
    const float2 texelSize = 1 / TexSize;

    //create indices to crawl
    const uint2 pixels[9] =
        {
        uint2(id.x - offset, id.y - offset),
        uint2(id.x, id.y - offset), uint2(id.x + offset, id.y - offset),
        uint2(id.x - offset, id.y), uint2(id.x, id.y), uint2(id.x, id.y + offset),
        uint2(id.x - offset, id.y + offset), uint2(id.x, id.y + offset), uint2(id.x + offset, id.y + offset)
        };
    
    int _id = -1;
    float _max = 1000000000;
    
    for (int a =0; a<9; a++)
    {
        //pixel we're evaluating
        const uint2 pix = pixels[a];
        //the uv stored in pixel
        float2 val = Result[pix].xy;    
        //make sure the uv is nonzero
        if (length(val) == 0)
            continue;
        //calculate the distance between us and the uv of stored pixel
        float _dist = distance(uv, val);
        //shortest distance evaluation
        if (_dist < _max)
        {
            _max = _dist;
            _id = a;
        }
    }
    
    if (_id < 0)
        return;
    float2 closest = Result[pixels[_id]].xy;
    Result[id.xy] = float4(closest, 0, 1);
    //Result[uint2(id.x, offset * 20)] = float4(1, 0, 0, 1);
    //Result[id.xy] = Result[id.xy];
}

[numthreads(8, 8, 1)]
void JFA_DistanceField(uint3 id : SV_DispatchThreadID)
{
    
}




